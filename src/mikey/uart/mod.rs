pub mod redeye_status;

#[cfg(not(feature = "comlynx_shared_memory"))]
pub mod comlynx_cable_mutex;
use alloc::vec::Vec;
#[cfg(not(feature = "comlynx_shared_memory"))]
use comlynx_cable_mutex::ComlynxCable;
#[cfg(feature = "comlynx_shared_memory")]
pub mod comlynx_cable_shared_memory;
use super::{alloc, trace, Deserialize, MikeyRegisters, SerCtlR, SerCtlW, Serialize};
#[cfg(feature = "comlynx_shared_memory")]
use comlynx_cable_shared_memory::ComlynxCable;
use redeye_status::RedeyeStatus;

macro_rules! bool_parity {
    ($bit: expr) => {
        match $bit {
            true => RedeyeStatus::High,
            false => RedeyeStatus::Low,
        }
    };
}

#[derive(Serialize, Deserialize)]
pub struct Uart {
    receive_register_len: u8,
    receive_register_buffer: u8,
    receive_register: Option<u8>,
    break_count: u64,
    transmit_register: Vec<RedeyeStatus>,
    transmit_holding_register: Option<u8>,
    redeye_pin: ComlynxCable,
    generator_delay: u8,
    #[cfg(feature = "comlynx_external")]
    #[serde(skip)]
    ext_tx: Option<kanal::Sender<u8>>,
    #[cfg(feature = "comlynx_external")]
    #[serde(skip)]
    ext_rx: Option<kanal::Receiver<u8>>,
}

impl Uart {
    #[must_use]
    pub fn new() -> Self {
        Self {
            receive_register_len: 0,
            receive_register: None,
            receive_register_buffer: 0,
            generator_delay: 8,
            break_count: 0,
            transmit_register: vec![],
            transmit_holding_register: None,
            redeye_pin: ComlynxCable::default(),
            #[cfg(feature = "comlynx_external")]
            ext_tx: None,
            #[cfg(feature = "comlynx_external")]
            ext_rx: None,
        }
    }

    #[cfg(feature = "comlynx_external")]
    pub fn set_external_comlynx(&mut self, ext_tx: kanal::Sender<u8>, ext_rx: kanal::Receiver<u8>) {
        self.ext_tx = Some(ext_tx);
        self.ext_rx = Some(ext_rx);
    }

    pub fn reset(&mut self) {
        self.receive_register_len = 0;
        self.receive_register = None;
        self.receive_register_buffer = 0;
        self.break_count = 0;
        self.transmit_register.clear();
        self.transmit_holding_register = None;
    }

    pub fn tick(&mut self, regs: &mut MikeyRegisters) -> bool /* tx or rx ready interrupt */ {
        /* "
        The baud rate is generated by TIMER4 according to the equation
        CLOCK4 / (TIMER4 + 1) / 8
        " */
        if self.generator_delay == 0 {
            self.generator_delay = 8;
        } else {
            self.generator_delay -= 1;
            return false;
        }

        #[cfg(feature = "comlynx_external")]
        if !regs.serctl_r_is_flag_set(SerCtlR::rx_rdy)
            && regs.serctl_r_is_flag_set(SerCtlR::tx_rdy)
            && regs.serctl_r_is_flag_set(SerCtlR::tx_empty)
        {
            if let Ok(Some(rx_data)) = self.ext_rx.as_ref().unwrap().try_recv() {
                self.receive_register = Some(rx_data);
                regs.serctl_r_enable_flag(SerCtlR::rx_rdy);
                regs.serctl_r_disable_flag(SerCtlR::par_err);
                regs.serctl_r_disable_flag(SerCtlR::overrun);
                regs.serctl_r_disable_flag(SerCtlR::frame_err);
            }
        }

        /* "
        Both the transmit and receive interrupts are 'level' sensitive, rather than 'edge' sensitive.
        This means that an interrupt will be continuously generated as long as it is enabled and its UART buffer is ready.
        " */
        self.tx(regs);
        self.rx(regs);

        (regs.serctl_w_is_flag_set(SerCtlW::tx_int_en)
            && regs.serctl_r_is_flag_set(SerCtlR::tx_rdy))
            | (regs.serctl_w_is_flag_set(SerCtlW::rx_int_en)
                && regs.serctl_r_is_flag_set(SerCtlR::rx_rdy))
    }

    fn tx(&mut self, regs: &mut MikeyRegisters) {
        if regs.serctl_w_is_flag_set(SerCtlW::tx_brk) {
            self.set_redeye_pin(RedeyeStatus::Low);
            return;
        }

        if self.transmit_register.is_empty() {
            if let Some(data) = self.transmit_holding_register.take() {
                trace!("Transmitting 0x{data:02X}");
                self.load_transmit_data(data, regs);
                regs.serctl_r_enable_flag(SerCtlR::tx_rdy);
                regs.serctl_r_disable_flag(SerCtlR::tx_empty);
            }
            if self.transmit_holding_register.is_none() {
                regs.serctl_r_enable_flag(SerCtlR::tx_empty);
            }
        }

        if let Some(to_send) = self.transmit_register.pop() {
            self.set_redeye_pin(to_send);
        }
    }

    fn load_transmit_data(&mut self, mut data: u8, regs: &mut MikeyRegisters) {
        #[cfg(feature = "comlynx_external")]
        let _ = self.ext_tx.as_ref().unwrap().send(data);

        self.transmit_register.clear();
        // stop bit
        self.transmit_register.push(RedeyeStatus::High);
        // parity
        self.transmit_register
            .push(if regs.serctl_w_is_flag_set(SerCtlW::par_en) {
                let par = bool_parity!(data.count_ones() & 1 == 1);
                match par {
                    RedeyeStatus::High => regs.serctl_r_enable_flag(SerCtlR::par_bit),
                    RedeyeStatus::Low => regs.serctl_r_disable_flag(SerCtlR::par_bit),
                }
                par
            } else {
                bool_parity!(regs.serctl_w_is_flag_set(SerCtlW::par_even))
            });
        // data
        for _i in 0..8 {
            self.transmit_register.push(if data & 0x01 != 0 {
                RedeyeStatus::High
            } else {
                RedeyeStatus::Low
            });
            data >>= 1;
        }
        // start bit
        self.transmit_register.push(RedeyeStatus::Low);
    }

    fn rx(&mut self, regs: &mut MikeyRegisters) {
        let redeye_status = self.redeye_pin.status();

        match redeye_status {
            RedeyeStatus::Low => {
                self.break_count += 1;
                if self.break_count >= 24 {
                    regs.serctl_r_enable_flag(SerCtlR::rx_brk);
                    return;
                }
            }
            RedeyeStatus::High => {
                self.break_count = 0;
                regs.serctl_r_disable_flag(SerCtlR::rx_brk);
            }
        }

        match self.receive_register_len {
            0 => {
                if redeye_status == RedeyeStatus::Low {
                    self.receive_register_buffer = 0;
                    self.receive_register_len = 1;
                }
            }
            1..=8 => {
                self.receive_register_buffer <<= 1;
                self.receive_register_buffer |= u8::from(redeye_status == RedeyeStatus::High);
                self.receive_register_len += 1;
            }
            9 => {
                if regs.serctl_w_is_flag_set(SerCtlW::par_en) {
                    let par = bool_parity!(self.receive_register_buffer.count_ones() & 1 == 1);
                    if par == RedeyeStatus::High {
                        regs.serctl_r_enable_flag(SerCtlR::par_bit);
                    } else {
                        regs.serctl_r_disable_flag(SerCtlR::par_bit);
                    }
                    if par != redeye_status {
                        trace!("Parity Error");
                        regs.serctl_r_enable_flag(SerCtlR::par_err);
                    }
                } else if redeye_status
                    != bool_parity!(regs.serctl_w_is_flag_set(SerCtlW::par_even))
                {
                    trace!("Parity Error");
                    regs.serctl_r_enable_flag(SerCtlR::par_err);
                }
                self.receive_register_len += 1;
            }
            10 => {
                if self.receive_register_buffer != 0 && redeye_status == RedeyeStatus::Low {
                    trace!("Frame Error");
                    regs.serctl_r_enable_flag(SerCtlR::frame_err);
                }
                trace!("Received 0x{:02X}", self.receive_register_buffer);
                if self.receive_register.is_some() {
                    trace!("Overrun");
                    regs.serctl_r_enable_flag(SerCtlR::overrun);
                } else {
                    self.receive_register = Some(self.receive_register_buffer);
                    regs.serctl_r_enable_flag(SerCtlR::rx_rdy);
                }
                self.receive_register_len = 0;
            }
            _ => (),
        }
    }

    pub fn get_data(&mut self, regs: &mut MikeyRegisters) -> u8 {
        regs.serctl_r_disable_flag(SerCtlR::rx_rdy);
        match self.receive_register.take() {
            None => 0,
            Some(data) => {
                trace!("Get 0x{data:02X}");
                data
            }
        }
    }

    pub fn set_transmit_holding_buffer(&mut self, regs: &mut MikeyRegisters, data: u8) {
        trace!("set_transmit_holding_buffer {data:02X}");
        self.transmit_holding_register = Some(data);
        regs.serctl_r_disable_flag(SerCtlR::tx_rdy);
        regs.serctl_r_disable_flag(SerCtlR::tx_empty);
    }

    pub fn set_redeye_pin(&mut self, status: RedeyeStatus) {
        self.redeye_pin.set(status);
    }

    #[cfg(not(feature = "comlynx_shared_memory"))]
    pub fn set_cable(&mut self, cable: &ComlynxCable) {
        self.redeye_pin = cable.clone();
    }

    #[must_use]
    pub fn cable(&self) -> &ComlynxCable {
        &self.redeye_pin
    }
}

impl Default for Uart {
    fn default() -> Self {
        Self::new()
    }
}
